Index: manifest.xml
===================================================================
--- manifest.xml	(revision 31156)
+++ manifest.xml	(working copy)
@@ -13,6 +13,9 @@
   <depend package="colladadom" />
   <depend package="resource_retriever" />
   <depend package="angles" />
+
+  <rosdep name="libgts" />
+
   <platform os="ubuntu" version="9.04"/>
   <platform os="ubuntu" version="9.10"/>
   <platform os="ubuntu" version="10.04"/>
Index: src/collada_writer.cpp
===================================================================
--- src/collada_writer.cpp	(revision 31156)
+++ src/collada_writer.cpp	(working copy)
@@ -42,6 +42,11 @@
 #include <boost/date_time/posix_time/posix_time_io.hpp>
 #include <boost/foreach.hpp>
 
+extern "C" {
+#include <gtsconfig.h>
+#include <gts.h>
+}
+
 #define foreach BOOST_FOREACH
 
 using std::string;
@@ -193,6 +198,234 @@
     // </technique_common>
 }
 
+static void buildMeshFromGTSSurface(GtsTriangle * t, shared_ptr<Mesh> mesh_)
+{
+  GtsVertex * v1, * v2, * v3;
+  GtsVector n;
+
+  gts_triangle_vertices (t, &v1, &v2, &v3);
+  gts_triangle_normal (t, &n[0], &n[1], &n[2]);
+  gts_vector_normalize (n);
+
+  Vector3 normal(n[0], n[1], n[2]);
+  Vector3 vertex1(GTS_POINT (v1)->x, GTS_POINT (v1)->y, GTS_POINT (v1)->z);
+  Vector3 vertex2(GTS_POINT (v2)->x, GTS_POINT (v2)->y, GTS_POINT (v2)->z);
+  Vector3 vertex3(GTS_POINT (v3)->x, GTS_POINT (v3)->y, GTS_POINT (v3)->z);
+
+  int index;
+  index = mesh_->getVertexIndex(vertex1);
+  if (index == -1) {
+    mesh_->addVertex(vertex1);
+    mesh_->addNormal(normal);
+    index = mesh_->vertices.size() - 1;
+  }
+  mesh_->addIndex(index);
+
+  index = mesh_->getVertexIndex(vertex2);
+  if (index == -1) {
+    mesh_->addVertex(vertex2);
+    mesh_->addNormal(normal);
+    index = mesh_->vertices.size() - 1;
+  }
+  mesh_->addIndex(index);
+
+  index = mesh_->getVertexIndex(vertex3);
+  if (index == -1) {
+    mesh_->addVertex(vertex3);
+    mesh_->addNormal(normal);
+    index = mesh_->vertices.size() - 1;
+  }
+  mesh_->addIndex(index);
+}
+  /* Gerris - The GNU Flow Solver
+   * Copyright (C) 2001 National Institute of Water and Atmospheric Research
+   */
+static GtsSurface * triangulate (GSList * vertices,
+                                 GSList * constraints)
+{
+  GtsVertex * v1, * v2, * v3;
+  GtsSurface * s;
+  GSList * i;
+
+  v1 = gts_vertex_new (gts_vertex_class (), -1e10, -1e10, 0.);
+  v2 = gts_vertex_new (gts_vertex_class (), 1e10, -1e10, 0.);
+  v3 = gts_vertex_new (gts_vertex_class (), 0., 1e10, 0.);
+  s = gts_surface_new (gts_surface_class (),
+                       gts_face_class (),
+                       gts_edge_class (),
+                       gts_vertex_class ());
+  gts_surface_add_face (s, gts_face_new (gts_face_class (),
+                                         gts_edge_new (gts_edge_class (), v1, v2),
+                                         gts_edge_new (gts_edge_class (), v2, v3),
+                                         gts_edge_new (gts_edge_class (), v3, v1)));
+  i = vertices;
+  while (i) {
+    if (gts_delaunay_add_vertex (s, (GtsVertex *)i->data, NULL) != NULL) {
+      gts_object_destroy (GTS_OBJECT (s));
+      return NULL;
+    }
+    i = i->next;
+  }
+
+  i = constraints;
+  while (i) {
+    if (gts_delaunay_add_constraint (s, (GtsConstraint *)i->data) != NULL) {
+      gts_object_destroy (GTS_OBJECT (s));
+      return NULL;
+    }
+    i = i->next;
+  }
+
+  gts_delaunay_remove_hull (s);
+
+  return s;
+}
+
+static GSList * contour (GSList * i, GtsSurface * s,
+                         gdouble z, gboolean closed)
+{
+  GSList * edges = NULL;
+  GtsVertex * vold = NULL, * vin = NULL;
+
+  if (i == NULL || i->next == NULL)
+    return NULL;
+
+  while (i) {
+    GtsPoint * p = (GtsPoint *)i->data;
+    GtsVertex * v;
+
+    v = gts_vertex_new (s->vertex_class, p->x, p->y, z);
+    if (vold)
+      edges = g_slist_prepend (edges,
+                               gts_edge_new (GTS_EDGE_CLASS (gts_constraint_class ()), v, vold));
+    else
+      vin = v;
+    vold = v;
+    i = i->next;
+  }
+  if (closed)
+    edges = g_slist_prepend (edges,
+                             gts_edge_new (GTS_EDGE_CLASS (gts_constraint_class ()), vin, vold));
+  return edges;
+}
+
+static void surface_add_shape (GtsSurface * s,
+                               GSList * shape,
+                               gdouble z1,
+                               gdouble z2,
+                               guint nz,
+                               gboolean closed,
+                               gboolean ends)
+{
+  gdouble z, dz = (z2 - z1)/nz;
+  guint i;
+  GSList * bottom = NULL, * e1 = NULL, * e2 = NULL;
+
+  for (i = 0, z = z1; i <= nz; i++, z += dz) {
+    if (e1 == NULL)
+      bottom = e1 = contour (shape, s, z, closed);
+    else {
+      GSList * i, * j;
+      GtsEdge * eold = NULL, * ein = NULL;
+
+      e2 = contour (shape, s, z, closed);
+      i = e1; j = e2;
+      while (i && j) {
+        GtsEdge * e;
+        GtsEdge * ee = gts_edge_new (gts_edge_class (),
+                                     GTS_SEGMENT (i->data)->v2,
+                                     GTS_SEGMENT (j->data)->v1);
+
+        if (!closed || i->next != NULL)
+          e = gts_edge_new (gts_edge_class (),
+                            GTS_SEGMENT (i->data)->v2,
+                            GTS_SEGMENT (j->data)->v2);
+        else
+          e = ein;
+        if (eold == NULL)
+          eold = ein = gts_edge_new (gts_edge_class (),
+                                     GTS_SEGMENT (i->data)->v1,
+                                     GTS_SEGMENT (j->data)->v1);
+        gts_surface_add_face (s, gts_face_new (s->face_class,
+                                               (GtsEdge*)i->data, eold, ee));
+        gts_surface_add_face (s, gts_face_new (s->face_class,
+                                               e, ee, (GtsEdge*)j->data));
+        eold = e;
+        i = i->next;
+        j = j->next;
+      }
+      if (e1 != bottom) g_slist_free (e1);
+      e1 = e2;
+    }
+  }
+
+  if (ends) {
+    GSList * vertices1 = gts_vertices_from_segments (bottom);
+    GSList * vertices2 = gts_vertices_from_segments (e1);
+    GtsSurface * s1 = triangulate (vertices1, bottom);
+    GtsSurface * s2 = triangulate (vertices2, e1);
+
+    if (s1 == NULL || s2 == NULL) {
+      GSList * i = shape;
+
+      while (i) {
+        fprintf (stderr, "%g %g\n",
+                 GTS_POINT (i->data)->x,
+                 GTS_POINT (i->data)->y);
+        i = i->next;
+      }
+      fprintf (stderr, "\n");
+      if (s1) gts_object_destroy (GTS_OBJECT (s1));
+      if (s2) gts_object_destroy (GTS_OBJECT (s2));
+    }
+    else {
+      gts_surface_foreach_face (s2, (GtsFunc) gts_triangle_revert, NULL);
+
+      gts_surface_merge (s, s1);
+      gts_surface_merge (s, s2);
+
+      gts_object_destroy (GTS_OBJECT (s1));
+      gts_object_destroy (GTS_OBJECT (s2));
+    }
+    g_slist_free (vertices1);
+    g_slist_free (vertices2);
+  }
+
+  g_slist_free (bottom);
+  g_slist_free (e1);
+}
+
+static void surface_add_ellipse_shape (GtsSurface * s,
+                                       gdouble x, gdouble y,
+                                       gdouble radius,
+                                       gdouble theta,
+                                       gdouble thetamax,
+                                       gdouble e,
+                                       gdouble z1, gdouble z2,
+                                       guint np,
+                                       gboolean closed)
+{
+  GSList * shape = NULL;
+  guint i, npm = np;
+
+  g_return_if_fail (s != NULL);
+  g_return_if_fail (np >= 3);
+
+  if (thetamax < 2.*M_PI)
+    npm = np + 1;
+  for (i = 0; i < npm; i++) {
+    gdouble theta1 = theta + i*thetamax/(gdouble) np;
+    shape = g_slist_prepend (shape,
+                             gts_point_new (gts_point_class (),
+                                            x + radius*e*cos (theta1),
+                                            y + radius/e*sin (theta1),
+                                            0.));
+  }
+  surface_add_shape (s, shape, z1, z2, 10, TRUE, closed);
+  g_slist_free (shape);
+}
+
+
 void ColladaWriter::addGeometries() {
     int link_num = 0;
 
@@ -224,14 +457,143 @@
             }
             case urdf::Geometry::SPHERE: {
                 std::cerr << "Warning: geometry type SPHERE of link " << urdf_link->name << " not exported" << std::endl;
+                urdf::Sphere* urdf_sphere = (urdf::Sphere*) geometry.get();
+                // <geometry id="g1.link0.geom0">
+                domGeometryRef geometry = daeSafeCast<domGeometry>(geometriesLib_->add(COLLADA_ELEMENT_GEOMETRY));
+                string geometry_id = string("g1.link") + boost::lexical_cast<string>(link_num) + string(".geom0");
+                geometry->setId(geometry_id.c_str());
+                {
+                  //Build the COLLADA mesh;
+                  shared_ptr<Mesh> mesh = shared_ptr<Mesh>(new Mesh);
+                  GtsSurface * s;
+                  guint level=4;
+                  //
+                  /* generate triangulated sphere */
+                  s = gts_surface_new (gts_surface_class (),
+                                       gts_face_class (),
+                                       gts_edge_class (),
+                                       gts_vertex_class ());
+                  gts_surface_generate_sphere (s, level);
+
+                  gts_surface_foreach_face (s, (GtsFunc) buildMeshFromGTSSurface, static_cast<void *>(&mesh));
+
+                  vector<Vector3>::iterator mesh_end(mesh->vertices.end());
+                  for(vector<Vector3>::iterator p = mesh->vertices.begin(); p != mesh_end; ++p) {
+                    (*p).x *= urdf_sphere->radius;;
+                    (*p).y *= urdf_sphere->radius;;
+                    (*p).z *= urdf_sphere->radius;;
+                  }
+
+                  buildMeshFromSTLLoader(mesh, geometry, geometry_id);
+                }
+                geometry_ids_[urdf_link->name] = geometry_id;
+                // </geometry>
+
+                link_num++;
                 break;
             }
             case urdf::Geometry::BOX: {
-                std::cerr << "Warning: geometry type BOX of link " << urdf_link->name << " not exported" << std::endl;
+                urdf::Box* urdf_box = (urdf::Box*) geometry.get();
+                // <geometry id="g1.link0.geom0">
+                domGeometryRef geometry = daeSafeCast<domGeometry>(geometriesLib_->add(COLLADA_ELEMENT_GEOMETRY));
+                string geometry_id = string("g1.link") + boost::lexical_cast<string>(link_num) + string(".geom0");
+                geometry->setId(geometry_id.c_str());
+                {
+                  //Build the COLLADA mesh;
+                  shared_ptr<Mesh> mesh = shared_ptr<Mesh>(new Mesh);
+                  GtsSurface * s;
+                  GtsVertex * v1, * v2, * v3, * v4, * v5, * v6, * v7, * v8;
+                  GtsEdge * e1, * e2, * e3, * e4, * e5, * e6, * e7, * e8, * e9,
+                    * e10, * e11, * e12, * e13, * e14, * e15, * e16, * e17, * e18;
+
+                  //
+                  /* generate triangulated box */
+                  s = gts_surface_new (gts_surface_class (),
+                                       gts_face_class (),
+                                       gts_edge_class (),
+                                       gts_vertex_class ());
+
+                  v1 = gts_vertex_new (s->vertex_class, -0.5*urdf_box->dim.x, -0.5*urdf_box->dim.y, -0.5*urdf_box->dim.z);
+                  v2 = gts_vertex_new (s->vertex_class,  0.5*urdf_box->dim.x, -0.5*urdf_box->dim.y, -0.5*urdf_box->dim.z);
+                  v3 = gts_vertex_new (s->vertex_class,  0.5*urdf_box->dim.x,  0.5*urdf_box->dim.y, -0.5*urdf_box->dim.z);
+                  v4 = gts_vertex_new (s->vertex_class, -0.5*urdf_box->dim.x,  0.5*urdf_box->dim.y, -0.5*urdf_box->dim.z);
+                  v5 = gts_vertex_new (s->vertex_class, -0.5*urdf_box->dim.x, -0.5*urdf_box->dim.y,  0.5*urdf_box->dim.z);
+                  v6 = gts_vertex_new (s->vertex_class,  0.5*urdf_box->dim.x, -0.5*urdf_box->dim.y,  0.5*urdf_box->dim.z);
+                  v7 = gts_vertex_new (s->vertex_class,  0.5*urdf_box->dim.x,  0.5*urdf_box->dim.y,  0.5*urdf_box->dim.z);
+                  v8 = gts_vertex_new (s->vertex_class, -0.5*urdf_box->dim.x,  0.5*urdf_box->dim.y,  0.5*urdf_box->dim.z);
+
+                  e1 = gts_edge_new (s->edge_class, v1, v2);
+                  e2 = gts_edge_new (s->edge_class, v2, v3);
+                  e3 = gts_edge_new (s->edge_class, v3, v4);
+                  e4 = gts_edge_new (s->edge_class, v4, v1);
+                  e5 = gts_edge_new (s->edge_class, v5, v6);
+                  e6 = gts_edge_new (s->edge_class, v6, v7);
+                  e7 = gts_edge_new (s->edge_class, v7, v8);
+                  e8 = gts_edge_new (s->edge_class, v8, v5);
+                  e9 = gts_edge_new (s->edge_class, v1, v5);
+                  e10 = gts_edge_new (s->edge_class, v2, v6);
+                  e11 = gts_edge_new (s->edge_class, v3, v7);
+                  e12 = gts_edge_new (s->edge_class, v4, v8);
+                  e13 = gts_edge_new (s->edge_class, v1, v6);
+                  e14 = gts_edge_new (s->edge_class, v2, v7);
+                  e15 = gts_edge_new (s->edge_class, v3, v8);
+                  e16 = gts_edge_new (s->edge_class, v4, v5);
+                  e17 = gts_edge_new (s->edge_class, v1, v3);
+                  e18 = gts_edge_new (s->edge_class, v5, v7);
+
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e13, e1, e10));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e13, e5,  e9));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e14, e2, e11));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e14, e6, e10));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e15, e3, e12));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e15, e7, e11));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e16, e4,  e9));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e16, e8, e12));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e17, e2,  e1));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e17, e4,  e3));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e18, e5,  e6));
+                  gts_surface_add_face (s, gts_face_new (s->face_class, e18, e7,  e8));
+
+                  gts_surface_foreach_face (s, (GtsFunc) buildMeshFromGTSSurface, static_cast<void *>(&mesh));
+
+                  buildMeshFromSTLLoader(mesh, geometry, geometry_id);
+                }
+                geometry_ids_[urdf_link->name] = geometry_id;
+                // </geometry>
+
+                link_num++;
                 break;
             }
             case urdf::Geometry::CYLINDER: {
-                std::cerr << "Warning: geometry type CYLINDER of link " << urdf_link->name << " not exported" << std::endl;
+                urdf::Cylinder* urdf_cylinder = (urdf::Cylinder*) geometry.get();
+                // <geometry id="g1.link0.geom0">
+                domGeometryRef geometry = daeSafeCast<domGeometry>(geometriesLib_->add(COLLADA_ELEMENT_GEOMETRY));
+                string geometry_id = string("g1.link") + boost::lexical_cast<string>(link_num) + string(".geom0");
+                geometry->setId(geometry_id.c_str());
+                {
+                  //Build the COLLADA mesh;
+                  shared_ptr<Mesh> mesh = shared_ptr<Mesh>(new Mesh);
+                  GtsSurface * s;
+                  guint number = 100;
+                  gboolean closed = TRUE;
+                  //
+                  /* generate triangulated cylinder */
+                  s = gts_surface_new (gts_surface_class (),
+                                       gts_face_class (),
+                                       gts_edge_class (),
+                                       gts_vertex_class ());
+                  surface_add_ellipse_shape (s, 0., 0., urdf_cylinder->radius,
+                                             0.001, 2*M_PI, 1., -0.5*urdf_cylinder->length, 0.5*urdf_cylinder->length, // @OK????
+                                             number, closed);
+
+                  gts_surface_foreach_face (s, (GtsFunc) buildMeshFromGTSSurface, static_cast<void *>(&mesh));
+
+                  buildMeshFromSTLLoader(mesh, geometry, geometry_id);
+                }
+                geometry_ids_[urdf_link->name] = geometry_id;
+                // </geometry>
+
+                link_num++;
                 break;
             }
             default: {
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 31156)
+++ CMakeLists.txt	(working copy)
@@ -1,14 +1,23 @@
 cmake_minimum_required(VERSION 2.4.6)
 include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
+include(FindPkgConfig)
+
 set(ROS_BUILD_TYPE Debug)
 rosbuild_init()
 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
 
+pkg_check_modules(GLIB REQUIRED glib-2.0)
+
+include_directories(${GLIB_INCLUDE_DIRS})
+link_directories(${GLIB_LIBRARY_DIRS})
+
 rosbuild_add_library(collada_urdf src/collada_urdf.cpp src/collada_writer.cpp src/stl_loader.cpp)
-rosbuild_link_boost(collada_urdf system)
+rosbuild_link_boost(collada_urdf system )
+target_link_libraries(collada_urdf ${GLIB_LIBRARIES} gts)
 
 rosbuild_add_executable(urdf_to_collada src/urdf_to_collada.cpp)
 target_link_libraries(urdf_to_collada collada_urdf)
 
 rosbuild_add_gtest(test_collada_writer test/test_collada_urdf.cpp)
 target_link_libraries(test_collada_writer collada_urdf)
+

